# app.py - Enhanced Streamlit Frontend with Conversational UI

import streamlit as st
import httpx
import asyncio
import plotly.graph_objects as go
import yaml
from pathlib import Path
from typing import List, Dict, Any
import time
import subprocess
import platform
import json

# Page Configuration
st.set_page_config(
    page_title="LocalLens - AI Document Search",
    page_icon="üîç",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Load Configuration
# Load Configuration
# CHANGE: Add encoding="utf-8" here
with open("config.yaml", "r", encoding="utf-8") as f:
    config = yaml.safe_load(f)

# API Client
class LocalLensAPI:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url
    
    async def health_check(self) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                response = await client.get(f"{self.base_url}/health")
                return response.json()
            except Exception as e:
                return {"status": "error", "message": str(e)}
    
    async def search(self, query: str, top_k: int = 5, use_hybrid: bool = True) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=60.0) as client:
            try:
                response = await client.post(
                    f"{self.base_url}/search",
                    json={
                        "query": query, 
                        "top_k": top_k,
                        "use_hybrid": use_hybrid
                    }
                )
                return response.json()
            except Exception as e:
                return {"status": "error", "message": str(e)}
    
    async def search_stream(self, query: str, top_k: int = 5):
        """Stream search with status updates"""
        async with httpx.AsyncClient(timeout=60.0) as client:
            try:
                async with client.stream(
                    "POST",
                    f"{self.base_url}/search/stream",
                    json={"query": query, "top_k": top_k, "use_hybrid": True}
                ) as response:
                    async for line in response.aiter_lines():
                        if line.startswith("data: "):
                            data = json.loads(line[6:])
                            yield data
            except Exception as e:
                yield {"status": "error", "message": str(e)}
    
    async def start_indexing(self, directory: str, watch_mode: bool = False) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                response = await client.post(
                    f"{self.base_url}/index",
                    json={"directory": directory, "watch_mode": watch_mode}
                )
                return response.json()
            except Exception as e:
                return {"status": "error", "message": str(e)}
    
    async def get_stats(self) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(f"{self.base_url}/stats")
                return response.json()
            except Exception:
                return {}
    
    async def get_clusters(self) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                response = await client.get(f"{self.base_url}/clusters")
                return response.json()
            except Exception:
                return {}

    async def get_ingestion_status(self) -> Dict[str, Any]:
        """Get current ingestion status"""
        async with httpx.AsyncClient(timeout=5.0) as client:
            try:
                response = await client.get(f"{self.base_url}/ingestion/status")
                return response.json()
            except Exception:
                return {"status": "error", "active_tasks": {}, "count": 0}


api = LocalLensAPI()


# Custom CSS
st.markdown("""
<style>
    /* Chat-like search interface */
    .chat-container {
        max-width: 800px;
        margin: 0 auto;
    }
    
    .user-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 20px 20px 5px 20px;
        margin: 10px 0;
        max-width: 80%;
        margin-left: auto;
    }
    
    .assistant-message {
        background: #f0f2f6;
        color: #1f2937;
        padding: 15px 20px;
        border-radius: 20px 20px 20px 5px;
        margin: 10px 0;
        max-width: 90%;
    }
    
    .status-message {
        background: #fef3c7;
        color: #92400e;
        padding: 10px 15px;
        border-radius: 10px;
        margin: 5px 0;
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .search-result {
        background: white;
        border: 1px solid #e5e7eb;
        border-left: 4px solid #21808d;
        padding: 15px 20px;
        margin: 10px 0;
        border-radius: 8px;
        transition: all 0.2s ease;
    }
    
    .search-result:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        transform: translateY(-2px);
    }
    
    .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .result-title {
        font-size: 16px;
        font-weight: 600;
        color: #1f2937;
    }
    
    .result-score {
        display: inline-block;
        background: linear-gradient(135deg, #21808d 0%, #1d7480 100%);
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 500;
    }
    
    .result-summary {
        color: #4b5563;
        font-size: 14px;
        line-height: 1.6;
        margin: 10px 0;
    }
    
    .result-path {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
        color: #9ca3af;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .intent-badge {
        display: inline-block;
        background: #dbeafe;
        color: #1e40af;
        padding: 3px 10px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
    }
    
    .stat-card {
        background: linear-gradient(135deg, #21808d 0%, #1d7480 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .stat-number {
        font-size: 32px;
        font-weight: bold;
    }
    
    .stat-label {
        font-size: 13px;
        opacity: 0.9;
    }
    
    /* Progress animation */
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    .thinking {
        animation: pulse 1.5s ease-in-out infinite;
    }

    /* Floating status widget */
    .status-widget {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 15px 20px;
        min-width: 300px;
        max-width: 400px;
        z-index: 1000;
        border-left: 4px solid #21808d;
    }

    .status-widget.processing {
        border-left-color: #f59e0b;
    }

    .status-widget.completed {
        border-left-color: #10b981;
    }

    .status-widget.error {
        border-left-color: #ef4444;
    }

    .status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
    }

    .status-title {
        font-weight: 600;
        font-size: 14px;
        color: #1f2937;
    }

    .status-body {
        font-size: 13px;
        color: #6b7280;
        margin-bottom: 8px;
    }

    .status-progress {
        width: 100%;
        height: 6px;
        background: #e5e7eb;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 8px;
    }

    .status-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #21808d, #1d7480);
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
    }

    @keyframes progressPulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .status-file {
        font-size: 12px;
        color: #9ca3af;
        font-family: 'Monaco', 'Menlo', monospace;
        margin-top: 5px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
</style>
""", unsafe_allow_html=True)


# Initialize session state
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
if 'last_query' not in st.session_state:
    st.session_state.last_query = ""
if 'show_ingestion_status' not in st.session_state:
    st.session_state.show_ingestion_status = False
if 'last_stats_update' not in st.session_state:
    st.session_state.last_stats_update = time.time()


# Sidebar Configuration
with st.sidebar:
    st.title("üîç LocalLens")
    st.caption("AI-Powered Document Search")
    
    st.divider()
    
    # Directory Selection
    st.subheader("üìÅ Document Source")
    target_dir = st.text_input(
        "Directory to Index",
        value=str(Path.home() / "Documents"),
        help="Select the directory containing your documents"
    )
    
    col1, col2 = st.columns(2)
    with col1:
        watch_mode = st.checkbox("üîÑ Watch", value=False, help="Auto-index new files")
    with col2:
        use_hybrid = st.checkbox("üîÄ Hybrid", value=True, help="Use hybrid search")
    
    if st.button("üöÄ Start Indexing", use_container_width=True):
        with st.spinner("Starting..."):
            result = asyncio.run(api.start_indexing(target_dir, watch_mode))
            if result.get("status") == "success":
                st.success(result.get("message", "Indexing started!"))
                st.session_state.show_ingestion_status = True
                time.sleep(1)
                st.rerun()  # Refresh to show status widget
            else:
                st.error(result.get("message", "Failed to start indexing"))
    
    st.divider()
    
    # Search Settings
    st.subheader("‚öôÔ∏è Search Settings")
    top_k = st.slider("Results to show", 1, 10, 5)
    
    st.divider()
    
    # System Status
    st.subheader("üìä System Status")
    
    if st.button("üîÑ Refresh Status"):
        with st.spinner("Checking..."):
            health = asyncio.run(api.health_check())
            if health.get("status") == "healthy":
                st.success("‚úÖ All systems operational")
                st.caption(f"Model: {health.get('model', 'N/A')}")
                st.caption(f"Hybrid Search: {'‚úì' if health.get('hybrid_search') else '‚úó'}")
            else:
                st.error(f"‚ùå {health.get('message', 'Connection error')}")


# Main Content
st.title("üîç LocalLens")
st.markdown("*Search your documents using natural language*")

# Statistics Dashboard
st.subheader("üìä Overview")
col1, col2, col3, col4 = st.columns(4)

try:
    stats = asyncio.run(api.get_stats())
    
    with col1:
        st.markdown(f"""
        <div class="stat-card">
            <div class="stat-number">{stats.get('total_documents', 0)}</div>
            <div class="stat-label">Documents</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown(f"""
        <div class="stat-card">
            <div class="stat-number">{stats.get('total_vectors', 0)}</div>
            <div class="stat-label">Vectors</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        hybrid_status = "‚úì" if stats.get('hybrid_search_enabled') else "‚úó"
        st.markdown(f"""
        <div class="stat-card">
            <div class="stat-number">{hybrid_status}</div>
            <div class="stat-label">Hybrid Search</div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div class="stat-card">
            <div class="stat-number">{stats.get('avg_search_time', 0.15):.2f}s</div>
            <div class="stat-label">Avg Search</div>
        </div>
        """, unsafe_allow_html=True)

except Exception:
    st.info("üìä Connect to backend to see statistics")

st.divider()

# Search Interface
st.subheader("üí¨ Ask LocalLens")

# Chat-like interface
chat_container = st.container()

# Search input
query = st.text_input(
    "What would you like to find?",
    placeholder="e.g., Find the invoice from last month's construction project",
    label_visibility="collapsed",
    key="search_input"
)

# Search button
col1, col2, col3 = st.columns([1, 1, 4])
with col1:
    search_clicked = st.button("üîç Search", use_container_width=True)
with col2:
    clear_clicked = st.button("üóëÔ∏è Clear", use_container_width=True)

if clear_clicked:
    st.session_state.chat_history = []
    st.rerun()

# Perform search
if query and (search_clicked or query != st.session_state.last_query):
    st.session_state.last_query = query
    
    # Add user message to history
    st.session_state.chat_history.append({
        "role": "user",
        "content": query
    })
    
    # Show status updates
    status_placeholder = st.empty()
    results_placeholder = st.empty()
    
    async def perform_search_with_status():
        statuses = []
        final_result = None
        
        # Show initial status
        status_placeholder.markdown("""
        <div class="status-message">
            <span class="thinking">üîç</span> Analyzing your query...
        </div>
        """, unsafe_allow_html=True)
        
        try:
            # Perform the search
            result = await api.search(query, top_k, use_hybrid)
            return result
        except Exception as e:
            return {"status": "error", "message": str(e)}
    
    with st.spinner(""):
        start_time = time.time()
        results = asyncio.run(perform_search_with_status())
        search_time = time.time() - start_time
    
    status_placeholder.empty()
    
    if results.get("status") == "success":
        # Add assistant response to history
        st.session_state.chat_history.append({
            "role": "assistant",
            "content": results.get("message", "Here are your results:"),
            "results": results.get("results", []),
            "intent": results.get("intent", "general"),
            "search_time": results.get("search_time", search_time)
        })
    else:
        st.session_state.chat_history.append({
            "role": "assistant",
            "content": f"‚ùå {results.get('message', 'Search failed')}",
            "results": [],
            "error": True
        })
    
    st.rerun()


# Display chat history
with chat_container:
    for msg in st.session_state.chat_history:
        if msg["role"] == "user":
            st.markdown(f"""
            <div class="user-message">
                üîç {msg['content']}
            </div>
            """, unsafe_allow_html=True)
        
        elif msg["role"] == "assistant":
            # Show assistant message
            intent = msg.get('intent', 'general')
            search_time = msg.get('search_time', 0)
            
            st.markdown(f"""
            <div class="assistant-message">
                <div style="margin-bottom: 10px;">
                    {msg['content']}
                </div>
                <div style="display: flex; gap: 10px; font-size: 12px; color: #6b7280;">
                    <span class="intent-badge">{intent}</span>
                    <span>‚è±Ô∏è {search_time:.2f}s</span>
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Show results
            results = msg.get('results', [])
            if results:
                for idx, result in enumerate(results, 1):
                    score = result.get('score', 0)
                    score_pct = min(score * 100, 100) if score <= 1 else score
                    
                    st.markdown(f"""
                    <div class="search-result">
                        <div class="result-header">
                            <span class="result-title">{idx}. {result['filename']}</span>
                            <span class="result-score">Score: {score:.3f}</span>
                        </div>
                        <div class="result-summary">
                            {result.get('content_summary', 'No summary available.')[:300]}...
                        </div>
                        <div class="result-path">
                            üìÇ {result['file_path']}
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # Open file button
                    if st.button(f"üìÇ Open", key=f"open_{result.get('id', idx)}_{len(st.session_state.chat_history)}"):
                        file_path = result['file_path']
                        try:
                            if platform.system() == 'Windows':
                                subprocess.Popen(['start', file_path], shell=True)
                            elif platform.system() == 'Darwin':
                                subprocess.Popen(['open', file_path])
                            else:
                                subprocess.Popen(['xdg-open', file_path])
                        except Exception as e:
                            st.error(f"Could not open file: {e}")

st.divider()

# Example queries
with st.expander("üí° Example Queries"):
    st.markdown("""
    Try these natural language queries:
    
    - **"Find invoices from construction project"** - Searches for invoice documents
    - **"Show me all images with diagrams"** - Filters to image files
    - **"What spreadsheets contain budget data?"** - Finds Excel/CSV files
    - **"Find contracts or agreements"** - Searches for legal documents
    - **"Show screenshots from last week"** - Looks for screenshot images
    
    The AI will automatically detect your intent and filter results accordingly!
    """)

# Cluster Visualization
with st.expander("üìä Document Clusters"):
    st.markdown("*Visualize how your documents are semantically grouped*")
    
    if st.button("Generate Visualization"):
        with st.spinner("Generating clusters..."):
            try:
                cluster_data = asyncio.run(api.get_clusters())
                
                if cluster_data and cluster_data.get("x"):
                    fig = go.Figure()
                    
                    unique_clusters = sorted(list(set(cluster_data['cluster_ids'])))
                    
                    for cluster_id in unique_clusters:
                        indices = [i for i, x in enumerate(cluster_data['cluster_ids']) if x == cluster_id]
                        
                        fig.add_trace(go.Scatter(
                            x=[cluster_data['x'][i] for i in indices],
                            y=[cluster_data['y'][i] for i in indices],
                            mode='markers',
                            name=f'Cluster {cluster_id}',
                            text=[cluster_data['labels'][i] for i in indices],
                            hoverinfo='text',
                            marker=dict(size=12, opacity=0.8)
                        ))
                    
                    fig.update_layout(
                        title="Document Semantic Clusters",
                        xaxis_title="Dimension 1",
                        yaxis_title="Dimension 2",
                        height=500,
                        hovermode='closest',
                        template="plotly_white"
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.warning("‚ö†Ô∏è No cluster data available. Index some documents first.")
            
            except Exception as e:
                st.error(f"‚ùå Visualization error: {str(e)}")

# Floating Ingestion Status Widget
status_placeholder = st.empty()

# Check for active ingestion tasks
try:
    ingestion_status_data = asyncio.run(api.get_ingestion_status())
    active_tasks = ingestion_status_data.get("active_tasks", {})

    if active_tasks:
        # Get the first active task
        task_id, task_info = list(active_tasks.items())[0]
        status = task_info.get("status", "processing")
        message = task_info.get("message", "Processing files...")
        current_file = task_info.get("current_file", "")
        processed = task_info.get("processed", 0)
        total_files = task_info.get("total_files", 0)

        # Calculate progress percentage
        progress_pct = (processed / total_files * 100) if total_files > 0 else 0

        # Determine status class
        status_class = "processing"
        icon = "‚öôÔ∏è"
        if status == "completed":
            status_class = "completed"
            icon = "‚úÖ"
        elif status == "error":
            status_class = "error"
            icon = "‚ùå"
        elif status == "started":
            status_class = "processing"
            icon = "üîç"

        # Render the status widget
        status_placeholder.markdown(f"""
        <div class="status-widget {status_class}">
            <div class="status-header">
                <span class="status-title">{icon} File Processing</span>
                <span style="font-size: 12px; color: #6b7280;">{processed}/{total_files}</span>
            </div>
            <div class="status-body">
                {message}
            </div>
            {f'<div class="status-file">üìÑ {current_file}</div>' if current_file else ''}
            <div class="status-progress">
                <div class="status-progress-bar" style="width: {progress_pct}%"></div>
            </div>
        </div>
        """, unsafe_allow_html=True)

        # Auto-refresh while processing
        if status in ["processing", "started"]:
            time.sleep(1)  # Faster refresh for real-time feel
            st.rerun()
        elif status == "completed":
            # Keep showing completed message for 3 seconds, then refresh stats
            time.sleep(3)
            st.session_state.last_stats_update = time.time()
            st.rerun()

except Exception as e:
    pass  # Silently fail if status check fails

# Footer
st.divider()
st.markdown("""
<div style="text-align: center; color: #9ca3af; font-size: 12px;">
    LocalLens v2.0 | AI-Powered Semantic Search<br>
    Built with Streamlit, FastAPI, and OpenSearch
</div>
""", unsafe_allow_html=True)
